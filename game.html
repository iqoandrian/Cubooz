<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Kubus 3D - Online Leaderboard</title>
    <!-- Memuat Tailwind CSS untuk styling UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Memuat Three.js untuk grafis 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Memuat Tone.js untuk audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }
        .overlay-ui { position: absolute; padding: 10px 20px; background-color: rgba(0, 0, 0, 0.7); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 1.1rem; font-weight: 600; text-align: center; border: 1px solid rgba(255, 255, 255, 0.2); backdrop-filter: blur(5px); }
        #game-info { top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; }
        .message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 40px; text-align: center; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 90%; max-width: 500px; background-color: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .title { font-size: 2.5rem; font-weight: bold; }
        .btn { background-color: #4a5568; padding: 12px 24px; border-radius: 8px; font-size: 1.1rem; font-weight: 600; margin-top: 20px; cursor: pointer; transition: background-color 0.3s, transform 0.2s; }
        .btn:hover { background-color: #2d3748; transform: scale(1.05); }
        #mute-btn { position: absolute; bottom: 20px; right: 20px; width: 50px; height: 50px; background-color: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 100; }
        #leaderboard { max-height: 200px; overflow-y: auto; text-align: left; font-size: 1rem; margin-top: 1rem;}
    </style>
</head>
<body>
    <!-- Layar Pemuatan -->
    <div id="loading-screen" class="message-box flex flex-col items-center">
        <h1 class="title mb-4">Memuat...</h1>
        <p class="mb-6">Memuat data pengguna dan Firebase...</p>
    </div>

    <!-- UI Game -->
    <div id="game-ui" class="hidden">
        <div id="game-info" class="overlay-ui">
            <div id="score-board">Skor: 0</div>
            <div id="timer">Waktu: 120</div>
            <div id="difficulty-display">Level: -</div>
        </div>
    </div>

    <!-- Pesan-pesan Game -->
    <div id="level-complete-message" class="message-box hidden flex-col items-center">...</div>
    <div id="win-message" class="message-box hidden flex-col items-center">
        <span class="title">Selamat!</span>
        <p class="mt-2 text-lg">Anda telah menyelesaikan semua level!</p>
        <p id="final-score" class="mt-4 text-2xl font-bold"></p>
        <div id="leaderboard-win" class="w-full"></div>
        <button class="btn" onclick="location.reload()">Main Lagi</button>
    </div>
    <div id="lose-message" class="message-box hidden flex-col items-center">
        <span class="title">Waktu Habis!</span>
        <p id="lose-score" class="mt-4 text-2xl font-bold"></p>
        <div id="leaderboard-lose" class="w-full"></div>
        <button class="btn" onclick="location.reload()">Coba Lagi</button>
    </div>
    
    <button id="mute-btn" class="hidden">
        <svg id="mute-icon" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" d="M9.383 3.064A1 1 0 0110 3v14a1 1 0 01-1.617.766L5.617 14H3a1 1 0 01-1-1V7a1 1 0 011-1h2.617l3.766-3.936zM15 7a1 1 0 011 1v4a1 1 0 11-2 0V8a1 1 0 011-1z" clip-rule="evenodd"></path>
        </svg>
    </button>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- Game and Firebase Variables ---
        let scene, camera, renderer, cubeGroup, starfield, currentUser;
        let totalScore = 0, timer, gameInterval, destroyedThisLevel = 0;
        const totalCubes = 4 * 4 * 4;
        let isGameOver = true, isMuted = false;
        let particles = [];
        const levels = ['Mudah', 'Sedang', 'Sulit'];
        let currentLevelIndex = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let synths = {};

        // Inisialisasi Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Inisialisasi ---
        initScene();
        initAudio();
        animate();

        // Autentikasi dan Logika Game
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                // Sembunyikan layar pemuatan, mulai game UI
                document.getElementById('loading-screen').classList.add('hidden');
                document.getElementById('mute-btn').classList.remove('hidden');
                document.getElementById('game-ui').classList.remove('hidden');
                startGame(levels[currentLevelIndex]);
            } else {
                 // Sembunyikan layar pemuatan dan tampilkan kembali
                 // jika pengguna tidak masuk
                 document.getElementById('loading-screen').classList.remove('hidden');
                 document.getElementById('loading-screen').innerHTML = `
                    <h1 class="title mb-4">Game Kubus 3D Online</h1>
                    <p class="mb-6">Silakan masuk untuk bermain dan menyimpan skor Anda!</p>
                `;
            }
        });

        // Autentikasi pengguna
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Gagal melakukan autentikasi dengan Firebase:", error);
            // Anda dapat menampilkan pesan kesalahan kepada pengguna di sini
        }

        // --- Logika Game ---
        function startGame(difficulty) {
            isGameOver = false;
            destroyedThisLevel = 0;
            timer = 120;
            updateUI();
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(updateTimer, 1000);
            Tone.Transport.start();
            if (!starfield) createStarfield();
            createRubikCube(difficulty);
        }

        function levelComplete() {
            loadNextLevel();
        }

        async function gameOver(isWin) {
            isGameOver = true;
            clearInterval(gameInterval);
            Tone.Transport.stop();
            document.getElementById('game-ui').classList.add('hidden');

            if (currentUser && currentUser.uid) {
                await saveScoreToLeaderboard(totalScore);
            }

            let messageBox, leaderboardContainerId;

            if (isWin) {
                messageBox = document.getElementById('win-message');
                leaderboardContainerId = 'leaderboard-win';
                document.getElementById('final-score').innerText = `Skor Akhir Anda: ${totalScore}`;
            } else {
                messageBox = document.getElementById('lose-message');
                leaderboardContainerId = 'leaderboard-lose';
                document.getElementById('lose-score').innerText = `Skor Akhir Anda: ${totalScore}`;
            }
            
            messageBox.classList.remove('hidden');
            messageBox.classList.add('flex');
            
            displayLeaderboard(leaderboardContainerId);
        }

        // --- Interaksi Firestore ---
        async function saveScoreToLeaderboard(score) {
            if (!currentUser) return;
            try {
                // Simpan data di jalur publik agar semua pengguna dapat melihatnya
                const leaderboardPath = `artifacts/${appId}/public/data/leaderboard`;
                await addDoc(collection(db, leaderboardPath), {
                    name: currentUser.displayName || `Pemain Anonim (${currentUser.uid.substring(0, 5)}...)`,
                    score: score,
                    uid: currentUser.uid,
                    timestamp: new Date()
                });
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        }
        
        async function displayLeaderboard(containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = `<h3 class="font-bold text-xl mb-2">Leaderboard Top 10</h3><div id="leaderboard" class="w-full">Memuat...</div>`;
            const leaderboardEl = container.querySelector('#leaderboard');
            
            try {
                const leaderboardPath = `artifacts/${appId}/public/data/leaderboard`;
                const q = query(collection(db, leaderboardPath));
                const querySnapshot = await getDocs(q);
                
                let scores = [];
                querySnapshot.forEach((doc) => {
                    scores.push(doc.data());
                });

                // Mengurutkan skor secara manual di sisi klien
                scores.sort((a, b) => b.score - a.score);
                
                let html = '<ol class="list-decimal list-inside">';
                scores.slice(0, 10).forEach((data) => {
                    const isCurrentUser = data.uid === currentUser.uid;
                    html += `<li class="${isCurrentUser ? 'font-bold text-yellow-400' : ''}">${data.name}: ${data.score}</li>`;
                });
                html += '</ol>';
                leaderboardEl.innerHTML = html;
            } catch (error) {
                console.error("Gagal memuat leaderboard:", error);
                leaderboardEl.innerText = "Gagal memuat leaderboard.";
            }
        }
        
        // --- Semua fungsi helper lainnya ---
        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            document.getElementById('mute-btn').addEventListener('click', toggleMute);
        }

        async function initAudio() {
            await Tone.start();
            synths.explosion = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            synths.bomb = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: "exponential" } }).toDestination();
            synths.time = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination();
            synths.error = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
        }

        function updateTimer() {
            if (isGameOver) return;
            timer--;
            updateUI();
            if (timer <= 0) {
                gameOver(false);
            }
        }

        function loadNextLevel() {
            currentLevelIndex++;
            if (currentLevelIndex < levels.length) {
                 startGame(levels[currentLevelIndex]);
            } else {
                 gameOver(true);
            }
        }

        function updateUI() {
            document.getElementById('score-board').innerText = `Skor: ${totalScore}`;
            document.getElementById('timer').innerText = `Waktu: ${timer}`;
            document.getElementById('difficulty-display').innerText = `Level: ${levels[currentLevelIndex]}`;
        }

        function createStarfield() {
            if (starfield) scene.remove(starfield);
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(200);
                const y = THREE.MathUtils.randFloatSpread(200);
                const z = THREE.MathUtils.randFloatSpread(200);
                starVertices.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        function createRubikCube(difficulty) {
            if (cubeGroup) scene.remove(cubeGroup);
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];
            
            cubeGroup = new THREE.Group();
            const size = 4, spacing = 1.1, cubeSize = 1;
            const offset = (size - 1) * spacing / 2;
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            let greenProps = { color: 0x22c55e, transparent: true, opacity: 1.0 };
            if (difficulty === 'Sedang') greenProps.opacity = 0.6;
            else if (difficulty === 'Sulit') { greenProps.opacity = 0.35; greenProps.color = 0x166534; }

            for (let i = 0; i < size; i++) for (let j = 0; j < size; j++) for (let k = 0; k < size; k++) {
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x111827, name: 'black' });
                const materials = Array(6).fill(blackMat);
                const faceIndex = Math.floor(Math.random() * 6);
                const cube = new THREE.Mesh(geometry, materials);
                cube.position.set(i * spacing - offset, j * spacing - offset, k * spacing - offset);
                cube.isSolved = false;
                cube.greenFaceIndex = faceIndex;
                cube.gridPos = {i, j, k};
                const rand = Math.random();
                if (rand < 0.05) { cube.type = 'bomb'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0xef4444, emissive: 0x550000, name: 'special' }); }
                else if (rand < 0.10) { cube.type = 'time'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x000055, name: 'special' }); }
                else { cube.type = 'normal'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ ...greenProps, name: 'special' }); }
                cubeGroup.add(cube);
            }
            scene.add(cubeGroup);
        }

        function handleCubeHit(clickedCube, faceIndex) {
            if (isGameOver || clickedCube.isSolved) return;
            
            if (faceIndex === clickedCube.greenFaceIndex) {
                totalScore += 2;
                switch(clickedCube.type) {
                    case 'time': timer += 5; playSound('time'); destroyCube(clickedCube); break;
                    case 'bomb': playSound('bomb'); detonateBomb(clickedCube); break;
                    default: playSound('explosion'); destroyCube(clickedCube); break;
                }
            } else {
                totalScore -= 1;
                playSound('error');
            }
            updateUI();
        }

        function destroyCube(cube) {
            if (cube.isSolved) return;
            cube.isSolved = true;
            destroyedThisLevel++;
            const color = cube.material[cube.greenFaceIndex].color;
            createExplosion(cube.getWorldPosition(new THREE.Vector3()), color);
            cubeGroup.remove(cube);
            if (destroyedThisLevel === totalCubes) {
                const timeBonus = timer;
                totalScore += timeBonus;
                loadNextLevel();
            }
        }
        
        function detonateBomb(bombCube) {
            destroyCube(bombCube);
            const { i, j, k } = bombCube.gridPos;
            const cubesToDestroy = [];
            cubeGroup.children.forEach(targetCube => {
                if (targetCube.isSolved) return;
                const { i: ti, j: tj, k: tk } = targetCube.gridPos;
                const dist = Math.max(Math.abs(i-ti), Math.abs(j-tj), Math.abs(k-tk));
                if (dist === 1) cubesToDestroy.push(targetCube);
            });
            cubesToDestroy.forEach((target, index) => {
                 setTimeout(() => {
                    if (!target.isSolved) {
                       totalScore += 2;
                       playSound('explosion');
                       destroyCube(target);
                       updateUI();
                    }
                }, 100 * (index / 5));
            });
        }
        
        function createExplosion(position, color) {
            const particleCount = 15;
            const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                particle.position.copy(position);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)
                ).normalize().multiplyScalar(Math.random() * 0.12 + 0.06);

                particles.push({ mesh: particle, velocity: velocity, lifetime: 1.2 });
                scene.add(particle);
            }
        }

        function playSound(type) {
            if (isMuted || !synths[type]) return;
            if (type === 'time') synths.time.triggerAttackRelease("C5", "0.5s");
            else if (type === 'error') synths.error.triggerAttackRelease("C2", "0.1s");
            else synths[type].triggerAttackRelease("8n");
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            Tone.Destination.mute = isMuted;
            const muteIcon = document.getElementById('mute-icon');
            if (isMuted) {
                 muteIcon.innerHTML = `<path fill-rule="evenodd" d="M15.414 14.586a2 2 0 01-2.828 0L10 12.828l-2.586 2.586a2 2 0 01-2.828-2.828L7.172 10 4.586 7.414a2 2 0 012.828-2.828L10 7.172l2.586-2.586a2 2 0 012.828 2.828L12.828 10l2.586 2.586a2 2 0 010 2.828z" clip-rule="evenodd"></path>`;
            } else {
                 muteIcon.innerHTML = `<path fill-rule="evenodd" d="M9.383 3.064A1 1 0 0110 3v14a1 1 0 01-1.617.766L5.617 14H3a1 1 0 01-1-1V7a1 1 0 011-1h2.617l3.766-3.936zM15 7a1 1 0 011 1v4a1 1 0 11-2 0V8a1 1 0 011-1z" clip-rule="evenodd"></path>`;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            if (isGameOver) return;
            isDragging = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onPointerMove(event) {
            if(Math.abs(event.clientX - previousMousePosition.x) > 5 || Math.abs(event.clientY - previousMousePosition.y) > 5) {
                isDragging = true;
            }
            if (isDragging && !isGameOver && cubeGroup) {
                const deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y };
                cubeGroup.rotation.y += deltaMove.x * 0.005;
                cubeGroup.rotation.x += deltaMove.y * 0.005;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onPointerUp(event) {
            if (!isDragging && !isGameOver) {
                 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                 raycaster.setFromCamera(mouse, camera);
                 const intersects = raycaster.intersectObjects(cubeGroup.children);
                 if (intersects.length > 0) {
                     handleCubeHit(intersects[0].object, intersects[0].face.materialIndex);
                 }
            }
            isDragging = false;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (cubeGroup && !isDragging && !isGameOver) {
                cubeGroup.rotation.y += 0.0005;
                cubeGroup.rotation.x += 0.0002;
            }
            if(starfield) starfield.rotation.y += 0.0001;
            particles.forEach((p, index) => {
                p.mesh.position.add(p.velocity);
                p.velocity.y -= 0.0015;
                p.lifetime -= 0.016;
                p.mesh.material.opacity = Math.max(0, p.lifetime);
                if (p.lifetime <= 0) { scene.remove(p.mesh); particles.splice(index, 1); }
            });
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

