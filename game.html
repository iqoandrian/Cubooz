<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Kubus 3D - Online Leaderboard</title>
    <!-- Memuat Tailwind CSS untuk styling UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Memuat Three.js untuk grafis 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Memuat Tone.js untuk audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <!-- SDK Firebase v9 -->
    <script type="module">
        // Import fungsi yang kita butuhkan dari SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

        // --- KONFIGURASI FIREBASE ANDA ---
        // GANTI DENGAN KONFIGURASI DARI PROYEK FIREBASE ANDA SENDIRI
        const firebaseConfig = {
          apiKey: "AIzaSy...YOUR_API_KEY",
          authDomain: "your-project-id.firebaseapp.com",
          projectId: "your-project-id",
          storageBucket: "your-project-id.appspot.com",
          messagingSenderId: "1234567890",
          appId: "1:1234567890:web:abcdef123456"
        };

        // Inisialisasi Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Simpan referensi ke fungsi agar bisa diakses global
        window.firebase = {
            auth,
            db,
            GoogleAuthProvider,
            signInWithPopup,
            onAuthStateChanged,
            collection,
            addDoc,
            query,
            orderBy,
            limit,
            onSnapshot,
            serverTimestamp
        };
    </script>

    <style>
        /* ... (CSS sama seperti sebelumnya) ... */
         body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }
        .overlay-ui { position: absolute; padding: 10px 20px; background-color: rgba(0, 0, 0, 0.7); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 1.1rem; font-weight: 600; text-align: center; border: 1px solid rgba(255, 255, 255, 0.2); backdrop-filter: blur(5px); }
        #game-info { top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; }
        .message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 40px; text-align: center; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 90%; max-width: 500px; background-color: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .title { font-size: 2.5rem; font-weight: bold; }
        .btn { background-color: #4a5568; padding: 12px 24px; border-radius: 8px; font-size: 1.1rem; font-weight: 600; margin-top: 20px; cursor: pointer; transition: background-color 0.3s, transform 0.2s; }
        .btn:hover { background-color: #2d3748; transform: scale(1.05); }
        #mute-btn { position: absolute; bottom: 20px; right: 20px; width: 50px; height: 50px; background-color: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 100; }
        #leaderboard { max-height: 200px; overflow-y: auto; text-align: left; font-size: 1rem; margin-top: 1rem;}
    </style>
</head>
<body>
    <!-- Layar Login -->
    <div id="login-screen" class="message-box flex flex-col items-center">
        <h1 class="title mb-4">Game Kubus 3D Online</h1>
        <p class="mb-6">Masuk dengan Google untuk bermain dan menyimpan skormu di leaderboard global!</p>
        <button id="login-btn" class="btn">
            Login dengan Google
        </button>
    </div>

    <!-- UI Game -->
    <div id="game-ui" class="hidden">
        <div id="game-info" class="overlay-ui">
            <div id="score-board">Skor: 0</div>
            <div id="timer">Waktu: 120</div>
            <div id="difficulty-display">Level: -</div>
        </div>
    </div>

    <!-- Pesan-pesan Game -->
    <div id="level-complete-message" class="message-box hidden flex-col items-center">...</div>
    <div id="win-message" class="message-box hidden flex-col items-center">
        <span class="title">Selamat!</span>
        <p class="mt-2 text-lg">Anda telah menyelesaikan semua level!</p>
        <p id="final-score" class="mt-4 text-2xl font-bold"></p>
        <div id="leaderboard-win" class="w-full"></div>
        <button class="btn" onclick="location.reload()">Main Lagi</button>
    </div>
    <div id="lose-message" class="message-box hidden flex-col items-center">
        <span class="title">Waktu Habis!</span>
        <p id="lose-score" class="mt-4 text-2xl font-bold"></p>
        <div id="leaderboard-lose" class="w-full"></div>
        <button class="btn" onclick="location.reload()">Coba Lagi</button>
    </div>
    
    <button id="mute-btn" class="hidden">...</button>

    <script type="module">
        // Variabel global
        let scene, camera, renderer, cubeGroup, starfield, currentUser;
        let totalScore = 0, timer, gameInterval, destroyedThisLevel = 0;
        const totalCubes = 4 * 4 * 4;
        let isGameOver = true, isMuted = false;
        let particles = [];
        const levels = ['Mudah', 'Sedang', 'Sulit'];
        let currentLevelIndex = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let synths = {};
        
        // --- Inisialisasi ---
        initScene();
        initAudio();
        animate();

        // --- Logika Autentikasi ---
        const { auth, db, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } = window.firebase;
        
        document.getElementById('login-btn').addEventListener('click', () => {
            const provider = new GoogleAuthProvider();
            signInWithPopup(auth, provider)
                .catch((error) => console.error("Login Gagal:", error));
        });

        onAuthStateChanged(auth, user => {
            if (user) {
                // User berhasil login
                currentUser = user;
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('mute-btn').classList.remove('hidden');
                startGame(levels[currentLevelIndex]); // Mulai game
            } else {
                // User logout atau belum login
                currentUser = null;
                document.getElementById('login-screen').classList.remove('hidden');
                document.getElementById('game-ui').classList.add('hidden');
            }
        });

        // --- Logika Game ---
        function startGame(difficulty) {
            isGameOver = false;
            document.getElementById('game-ui').classList.remove('hidden');
            destroyedThisLevel = 0;
            timer = 120;
            updateUI();
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(updateTimer, 1000);
            Tone.Transport.start();
            if (!starfield) createStarfield();
            createRubikCube(difficulty);
        }

        function levelComplete() {
            // ... (logika sama seperti sebelumnya)
            // ... (setelah menghitung skor, panggil loadNextLevel)
            loadNextLevel(); // Disederhanakan untuk langsung lanjut
        }
        
        async function gameOver(isWin) {
            isGameOver = true;
            clearInterval(gameInterval);
            Tone.Transport.stop();
            document.getElementById('game-ui').classList.add('hidden');

            // Simpan skor ke Firestore
            await saveScoreToLeaderboard(totalScore);

            let messageBox, leaderboardContainerId;

            if (isWin) {
                messageBox = document.getElementById('win-message');
                leaderboardContainerId = 'leaderboard-win';
                document.getElementById('final-score').innerText = `Skor Akhir Anda: ${totalScore}`;
            } else {
                messageBox = document.getElementById('lose-message');
                leaderboardContainerId = 'leaderboard-lose';
                document.getElementById('lose-score').innerText = `Skor Akhir Anda: ${totalScore}`;
            }
            
            messageBox.classList.remove('hidden');
            messageBox.classList.add('flex');
            
            displayLeaderboard(leaderboardContainerId);
        }

        // --- Interaksi Firestore ---
        async function saveScoreToLeaderboard(score) {
            const { db, collection, addDoc, serverTimestamp } = window.firebase;
            if (!currentUser) return; // Jangan simpan jika tidak login
            try {
                await addDoc(collection(db, "leaderboard"), {
                    name: currentUser.displayName,
                    score: score,
                    uid: currentUser.uid,
                    timestamp: serverTimestamp()
                });
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        }
        
        function displayLeaderboard(containerId) {
            const { db, collection, query, orderBy, limit, onSnapshot } = window.firebase;
            const container = document.getElementById(containerId);
            container.innerHTML = `<h3 class="font-bold text-xl mb-2">Leaderboard Top 10</h3><div id="leaderboard" class="w-full">Loading...</div>`;
            const leaderboardEl = container.querySelector('#leaderboard');
            
            const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(10));
            
            onSnapshot(q, (querySnapshot) => {
                let html = '<ol class="list-decimal list-inside">';
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const isCurrentUser = data.uid === currentUser.uid;
                    html += `<li class="${isCurrentUser ? 'font-bold text-yellow-400' : ''}">${data.name}: ${data.score}</li>`;
                });
                html += '</ol>';
                leaderboardEl.innerHTML = html;
            });
        }
        
        // --- Semua fungsi helper lainnya (initScene, animate, handleCubeHit, dll.) ---
        // Letakkan sisa kode JavaScript dari versi sebelumnya di sini.
        // Pastikan tidak ada duplikasi deklarasi variabel.
        function initScene() { /*...*/ }
        function initAudio() { /*...*/ }
        function updateTimer() { /*...*/ }
        function loadNextLevel() { /*...*/ }
        function updateUI() { /*...*/ }
        function createStarfield() { /*...*/ }
        function createRubikCube(difficulty) { /*...*/ }
        function handleCubeHit(clickedCube, faceIndex) { /*...*/ }
        function destroyCube(cube) { /*...*/ }
        function detonateBomb(bombCube) { /*...*/ }
        function createExplosion(position, color) { /*...*/ }
        function playSound(type) { /*...*/ }
        function toggleMute() { /*...*/ }
        function onWindowResize() { /*...*/ }
        function onPointerDown(event) { /*...*/ }
        function onPointerMove(event) { /*...*/ }
        function onPointerUp(event) { /*...*/ }
        function animate() { /*...*/ }

    </script>
    <script>
        // NOTE: Definisi fungsi-fungsi helper diletakkan di sini agar rapi.
        // Copy-paste semua fungsi yang ada di <script> sebelumnya ke sini.
        // Ini adalah cara untuk mengatasi batasan <script type="module">.
        let scene, camera, renderer, cubeGroup, starfield;
        let totalScore = 0, timer, gameInterval, destroyedThisLevel = 0;
        const totalCubes = 4*4*4;
        let isGameOver = true, isMuted = false;
        let particles = [];
        const levels = ['Mudah', 'Sedang', 'Sulit'];
        let currentLevelIndex = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let synths = {};

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            document.getElementById('mute-btn').addEventListener('click', toggleMute);
        }

        async function initAudio() {
            await Tone.start();
            synths.explosion = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            synths.bomb = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: "exponential" } }).toDestination();
            synths.time = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination();
            synths.error = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
        }

        function updateTimer() {
            if (isGameOver) return;
            timer--;
            updateUI();
            if (timer <= 0) {
                // Modul script akan menangani gameOver
                window.dispatchEvent(new CustomEvent('gameOver', { detail: { isWin: false } }));
            }
        }
        window.addEventListener('gameOver', (e) => gameOver(e.detail.isWin));


        function loadNextLevel() {
            currentLevelIndex++;
            if (currentLevelIndex < levels.length) {
                // Modul script akan menangani startGame
                 window.dispatchEvent(new CustomEvent('startGame', { detail: { difficulty: levels[currentLevelIndex] } }));
            } else {
                // Modul script akan menangani gameOver
                 window.dispatchEvent(new CustomEvent('gameOver', { detail: { isWin: true } }));
            }
        }
         window.addEventListener('startGame', (e) => startGame(e.detail.difficulty));


        function updateUI() {
            document.getElementById('score-board').innerText = `Skor: ${totalScore}`;
            document.getElementById('timer').innerText = `Waktu: ${timer}`;
            document.getElementById('difficulty-display').innerText = `Level: ${levels[currentLevelIndex]}`;
        }

        function createStarfield() {
            if (starfield) scene.remove(starfield);
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(200);
                const y = THREE.MathUtils.randFloatSpread(200);
                const z = THREE.MathUtils.randFloatSpread(200);
                starVertices.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        function createRubikCube(difficulty) {
            if (cubeGroup) scene.remove(cubeGroup);
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];
            
            cubeGroup = new THREE.Group();
            const size = 4, spacing = 1.1, cubeSize = 1;
            const offset = (size - 1) * spacing / 2;
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            let greenProps = { color: 0x22c55e, transparent: true, opacity: 1.0 };
            if (difficulty === 'Sedang') greenProps.opacity = 0.6;
            else if (difficulty === 'Sulit') { greenProps.opacity = 0.35; greenProps.color = 0x166534; }

            for (let i = 0; i < size; i++) for (let j = 0; j < size; j++) for (let k = 0; k < size; k++) {
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x111827, name: 'black' });
                const materials = Array(6).fill(blackMat);
                const faceIndex = Math.floor(Math.random() * 6);
                const cube = new THREE.Mesh(geometry, materials);
                cube.position.set(i * spacing - offset, j * spacing - offset, k * spacing - offset);
                cube.isSolved = false;
                cube.greenFaceIndex = faceIndex;
                cube.gridPos = {i, j, k};
                const rand = Math.random();
                if (rand < 0.05) { cube.type = 'bomb'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0xef4444, emissive: 0x550000, name: 'special' }); }
                else if (rand < 0.10) { cube.type = 'time'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x000055, name: 'special' }); }
                else { cube.type = 'normal'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ ...greenProps, name: 'special' }); }
                cubeGroup.add(cube);
            }
            scene.add(cubeGroup);
        }

        function handleCubeHit(clickedCube, faceIndex) {
            if (isGameOver || clickedCube.isSolved) return;
            
            if (faceIndex === clickedCube.greenFaceIndex) {
                totalScore += 2;
                switch(clickedCube.type) {
                    case 'time': timer += 5; playSound('time'); destroyCube(clickedCube); break;
                    case 'bomb': playSound('bomb'); detonateBomb(clickedCube); break;
                    default: playSound('explosion'); destroyCube(clickedCube); break;
                }
            } else {
                totalScore -= 1;
                playSound('error');
            }
            updateUI();
        }

        function destroyCube(cube) {
            if (cube.isSolved) return;
            cube.isSolved = true;
            destroyedThisLevel++;
            const color = cube.material[cube.greenFaceIndex].color;
            createExplosion(cube.getWorldPosition(new THREE.Vector3()), color);
            cubeGroup.remove(cube);
            if (destroyedThisLevel === totalCubes) {
                const timeBonus = timer;
                totalScore += timeBonus;
                loadNextLevel();
            }
        }
        
        function detonateBomb(bombCube) {
            destroyCube(bombCube);
            const { i, j, k } = bombCube.gridPos;
            const cubesToDestroy = [];
            cubeGroup.children.forEach(targetCube => {
                if (targetCube.isSolved) return;
                const { i: ti, j: tj, k: tk } = targetCube.gridPos;
                const dist = Math.max(Math.abs(i-ti), Math.abs(j-tj), Math.abs(k-tk));
                if (dist === 1) cubesToDestroy.push(targetCube);
            });
            cubesToDestroy.forEach((target, index) => {
                 setTimeout(() => {
                    if (!target.isSolved) {
                       totalScore += 2;
                       playSound('explosion');
                       destroyCube(target);
                       updateUI();
                    }
                }, 100 * (index / 5));
            });
        }
        
        function createExplosion(position, color) {
            const particleCount = 15;
            const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                particle.position.copy(position);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)
                ).normalize().multiplyScalar(Math.random() * 0.12 + 0.06);

                particles.push({ mesh: particle, velocity: velocity, lifetime: 1.2 });
                scene.add(particle);
            }
        }

        function playSound(type) {
            if (isMuted || !synths[type]) return;
            if (type === 'time') synths.time.triggerAttackRelease("C5", "0.5s");
            else if (type === 'error') synths.error.triggerAttackRelease("C2", "0.1s");
            else synths[type].triggerAttackRelease("8n");
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            Tone.Destination.mute = isMuted;
            // Anda mungkin perlu menambahkan kembali ikon mute/unmute
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            if (isGameOver) return;
            isDragging = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onPointerMove(event) {
            if(Math.abs(event.clientX - previousMousePosition.x) > 5 || Math.abs(event.clientY - previousMousePosition.y) > 5) {
                isDragging = true;
            }
            if (isDragging && !isGameOver && cubeGroup) {
                const deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y };
                cubeGroup.rotation.y += deltaMove.x * 0.005;
                cubeGroup.rotation.x += deltaMove.y * 0.005;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onPointerUp(event) {
            if (!isDragging && !isGameOver) {
                 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                 raycaster.setFromCamera(mouse, camera);
                 const intersects = raycaster.intersectObjects(cubeGroup.children);
                 if (intersects.length > 0) {
                     handleCubeHit(intersects[0].object, intersects[0].face.materialIndex);
                 }
            }
            isDragging = false;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (cubeGroup && !isDragging && !isGameOver) {
                cubeGroup.rotation.y += 0.0005;
                cubeGroup.rotation.x += 0.0002;
            }
            if(starfield) starfield.rotation.y += 0.0001;
            particles.forEach((p, index) => {
                p.mesh.position.add(p.velocity);
                p.velocity.y -= 0.0015;
                p.lifetime -= 0.016;
                p.mesh.material.opacity = Math.max(0, p.lifetime);
                if (p.lifetime <= 0) { scene.remove(p.mesh); particles.splice(index, 1); }
            });
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>

