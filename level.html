<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Game Kubus 3D - Progresif (Firebase Leaderboard)</title>

    <!-- Tailwind + Three.js + Tone.js -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <!-- Firebase (compat) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #05060a; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }
        .overlay-ui { position: absolute; padding: 10px 20px; background-color: rgba(0, 0, 0, 0.65); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 1rem; font-weight: 600; text-align: center; border: 1px solid rgba(255, 255, 255, 0.06); backdrop-filter: blur(4px); display: flex; gap: 12px; align-items:center; }
        #game-info { top: 20px; left: 50%; transform: translateX(-50%); z-index: 90; }

        .time-bar-wrapper { width: 220px; height: 14px; background: rgba(255,255,255,0.06); border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.06); }
        .time-bar { height:100%; width:100%; background: linear-gradient(90deg, #84cc16, #10b981); transform-origin: left; transition: width 0.25s linear; }

        .message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 36px; text-align: center; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 92%; max-width: 520px; background-color: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.08); opacity: 1; transition: opacity 0.35s ease; z-index: 100; }
        .hidden { display: none !important; }
        .title { font-size: 2.2rem; font-weight: 800; color: #e6edf3; }
        .btn { background-color: #334155; padding: 12px 22px; border-radius: 10px; font-size: 1.05rem; font-weight: 700; margin-top: 18px; cursor: pointer; transition: background-color 0.18s, transform 0.12s; color: #f8fafc; border: 1px solid rgba(255,255,255,0.04); }
        .btn:hover { background-color: #1f2937; transform: translateY(-2px); }
        #mute-btn { position: absolute; bottom: 20px; right: 20px; width: 52px; height: 52px; background-color: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255,255,255,0.08); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 100; }

        .floating-score { position: absolute; pointer-events: none; font-weight: 800; font-size: 18px; color: #bbf7d0; text-shadow: 0 4px 10px rgba(0,0,0,0.6); transform: translate(-50%, -50%) translateY(0); opacity: 1; transition: transform 900ms cubic-bezier(.2,.9,.2,1), opacity 900ms linear; z-index: 110; }

        #leaderboard { max-height: 360px; overflow: auto; }

        @media (max-width: 420px) {
            .overlay-ui { gap: 8px; padding: 8px 12px; font-size: 0.95rem; }
            .time-bar-wrapper { width: 160px; height: 12px; }
            .title { font-size: 1.6rem; }
        }
    </style>
</head>
<body>
    <!-- UI -->
    <div id="game-ui" class="hidden">
        <div id="game-info" class="overlay-ui">
            <div id="score-board">Skor: 0</div>
            <div class="time-bar-wrapper" title="Waktu tersisa">
                <div id="time-bar" class="time-bar" style="width:100%"></div>
            </div>
            <div id="timer">Waktu: 120</div>
            <div id="difficulty-display">Level: -</div>
        </div>
    </div>

    <!-- Login -->
    <div id="login-section" class="message-box">
        <span class="title">Login dengan Google</span>
        <p class="mt-3">Masuk untuk menyimpan skor ke leaderboard.</p>
        <button id="login-btn" class="btn">Login dengan Google</button>
        <p id="login-info" class="mt-2 text-sm" style="opacity:0.8"></p>
    </div>

    <!-- Start -->
    <div id="start-message" class="message-box hidden">
        <span class="title">Game Kubus 3D</span>
        <p class="mt-4 text-lg">Hancurkan sisi kubus yang berwarna hijau! Hati-hati dengan bom!</p>
        <button id="start-btn" class="btn">Mulai Game</button>
    </div>

    <!-- Level complete / win / lose -->
    <div id="level-complete-message" class="message-box hidden">
        <span class="title">Level Selesai!</span>
        <p id="level-score-breakdown" class="mt-4 text-lg"></p>
        <button id="continue-btn" class="btn">Lanjut</button>
    </div>
    <div id="win-message" class="message-box hidden">
        <span class="title">Selamat!</span>
        <p class="mt-2 text-lg">Anda telah menyelesaikan wave ini!</p>
        <p id="final-score" class="mt-4 text-2xl font-bold"></p>
        <button id="play-again-btn" class="btn">Main Lagi (reset)</button>
    </div>
    <div id="lose-message" class="message-box hidden">
        <span class="title">Waktu Habis!</span>
        <p id="lose-score" class="mt-4 text-2xl font-bold"></p>
        <button id="try-again-btn" class="btn">Coba Lagi</button>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboard" class="message-box hidden" style="left: auto; right: 20px; top: 20px; transform:none; width: 300px;">
        <span class="title">Leaderboard</span>
        <ul id="leaderboard-list" class="mt-4 space-y-2"></ul>
    </div>

    <!-- Mute + floating container -->
    <button id="mute-btn">
        <svg id="unmuted-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
        <svg id="muted-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
    </button>
    <div id="floating-container" style="position: absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:110;"></div>

<script>
/* =============================
   Firebase configuration - GANTI dengan config projectmu
   ============================= */
const firebaseConfig = {
  apiKey: "API_KEY_KAMU",
  authDomain: "PROJECT_ID.firebaseapp.com",
  projectId: "PROJECT_ID",
  storageBucket: "PROJECT_ID.appspot.com",
  messagingSenderId: "SENDER_ID",
  appId: "APP_ID"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

/* =============================
   Game code (gabungan fitur)
   ============================= */
let scene, camera, renderer, cubeGroup, starfield;
let totalScore = 0, timer = 120, initialTimer = 120, gameInterval = null, destroyedThisLevel = 0;
let currentCubeSize = 3; // progressive: mulai 3x3x3
const levels = ['Mudah','Sedang','Sulit'];
let currentLevelIndex = 0;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let synths = {};
let particles = [];
let isGameOver = true;
let isMuted = false;
let currentUser = null;

initScene();
animate();

function initScene(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 12;
    renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5,10,7.5);
    scene.add(dir);

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);

    document.getElementById('mute-btn').addEventListener('click', toggleMute);
    document.getElementById('continue-btn').addEventListener('click', loadNextLevel);
    document.getElementById('start-btn').addEventListener('click', async () => {
        // start only after login
        if (!currentUser) {
            alert('Silakan login terlebih dahulu dengan Google.');
            return;
        }
        document.getElementById('start-message').classList.add('hidden');
        await initAudio();
        startGame(levels[currentLevelIndex]);
    });
    document.getElementById('login-btn').addEventListener('click', googleLogin);
    document.getElementById('play-again-btn').addEventListener('click', resetGame);
    document.getElementById('try-again-btn').addEventListener('click', tryAgain);
    // show login UI initially
    document.getElementById('login-section').classList.remove('hidden');
}

/* Audio init */
async function initAudio(){
    await Tone.start();
    synths.explosion = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.002, decay: 0.12, sustain: 0, release: 0.18 } }).toDestination();
    synths.bomb = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 8, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.0 } }).toDestination();
    synths.time = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.4 } }).toDestination();
    synths.error = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.12, sustain: 0, release: 0.1 } }).toDestination();
    Tone.Destination.volume.value = isMuted ? -Infinity : 0;
}

/* Game control */
function startGame(difficulty){
    isGameOver = false;
    document.getElementById('game-ui').classList.remove('hidden');
    destroyedThisLevel = 0;

    initialTimer = (difficulty === 'Mudah') ? 120 : (difficulty === 'Sedang') ? 100 : 80;
    timer = initialTimer;
    updateUI();

    if (gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(updateTimer, 1000);
    Tone.Transport.start();

    if (!starfield) createStarfield();
    createRubikCube(difficulty);
}

function updateTimer(){
    timer--;
    updateUI();
    if (timer <= 0) {
        gameOver(false);
    }
}

function levelComplete(){
    isGameOver = true;
    clearInterval(gameInterval);
    Tone.Transport.stop();
    const timeBonus = timer;
    totalScore += timeBonus;
    document.getElementById('game-ui').classList.add('hidden');
    document.getElementById('level-score-breakdown').innerHTML = `Bonus Waktu: ${timeBonus} Poin<br>Total Skor Saat Ini: ${totalScore}`;
    document.getElementById('level-complete-message').classList.remove('hidden');
}

function loadNextLevel(){
    document.getElementById('level-complete-message').classList.add('hidden');
    currentLevelIndex++;
    if (currentLevelIndex < levels.length) {
        startGame(levels[currentLevelIndex]);
    } else {
        // completed all levels for this cube size -> increase size and continue
        currentLevelIndex = 0;
        currentCubeSize++;
        startGame(levels[currentLevelIndex]);
    }
}

async function gameOver(isWin){
    isGameOver = true;
    clearInterval(gameInterval);
    Tone.Transport.stop();
    document.getElementById('game-ui').classList.add('hidden');

    // store score to firestore if logged in
    if (currentUser) {
        try {
            await db.collection('leaderboard').doc(currentUser.uid).set({
                name: currentUser.displayName || 'Anon',
                score: totalScore,
                photo: currentUser.photoURL || null,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
        } catch (e) {
            console.error('Failed to write leaderboard:', e);
        }
    }

    if (isWin) {
        document.getElementById('final-score').innerText = `Skor Akhir Anda: ${totalScore}`;
        document.getElementById('win-message').classList.remove('hidden');
    } else {
        document.getElementById('lose-score').innerText = `Skor Akhir Anda: ${totalScore}`;
        document.getElementById('lose-message').classList.remove('hidden');
    }

    // show leaderboard
    loadLeaderboard();
}

/* UI updates */
function updateUI(){
    document.getElementById('score-board').innerText = `Skor: ${totalScore}`;
    document.getElementById('timer').innerText = `Waktu: ${timer}`;
    document.getElementById('difficulty-display').innerText = `Level: ${levels[currentLevelIndex] || '-'} (${currentCubeSize}x${currentCubeSize})`;

    const ratio = Math.max(0, Math.min(1, timer / initialTimer));
    const bar = document.getElementById('time-bar');
    bar.style.width = (ratio*100) + '%';
    if (ratio > 0.5) bar.style.background = 'linear-gradient(90deg, #84cc16, #10b981)';
    else if (ratio > 0.25) bar.style.background = 'linear-gradient(90deg, #f59e0b, #f97316)';
    else bar.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
}

/* 3D objects: starfield + cube */
function createStarfield() {
    const starCount = 2000;
    const starGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(starCount*3);
    const colors = new Float32Array(starCount*3);
    const color = new THREE.Color();
    for (let i=0;i<starCount;i++){
        positions[i*3] = THREE.MathUtils.randFloatSpread(200);
        positions[i*3+1] = THREE.MathUtils.randFloatSpread(200);
        positions[i*3+2] = THREE.MathUtils.randFloatSpread(200);
        color.setHSL(0.6,0.2,Math.random()*0.5+0.5);
        colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(colors,3));
    const starMaterial = new THREE.PointsMaterial({ size:0.09, sizeAttenuation:true, transparent:true, vertexColors:true });
    starfield = new THREE.Points(starGeometry, starMaterial);
    scene.add(starfield);
}

function createRubikCube(difficulty){
    if (cubeGroup) {
        scene.remove(cubeGroup);
        disposeGroup(cubeGroup);
    }
    particles.forEach(p => { scene.remove(p.mesh); if (p.mesh.geometry) p.mesh.geometry.dispose(); if (p.mesh.material) p.mesh.material.dispose(); });
    particles = [];

    cubeGroup = new THREE.Group();
    const size = currentCubeSize;
    const spacing = 1.05, cubeSize = 1;
    const offset = (size-1)*spacing/2;
    const geometry = new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize);

    let greenProps = { color: 0x22c55e, transparent: true, opacity: 1.0 };
    if (difficulty === 'Sedang') greenProps.opacity = 0.65;
    else if (difficulty === 'Sulit') { greenProps.opacity = 0.40; greenProps.color = 0x166534; }

    for (let i=0;i<size;i++){
        for (let j=0;j<size;j++){
            for (let k=0;k<size;k++){
                const materials = [];
                for (let m=0;m<6;m++) materials.push(new THREE.MeshStandardMaterial({ color:0x0b0f13, roughness:0.6, metalness:0.0 }));
                const faceIndex = Math.floor(Math.random()*6);
                const cube = new THREE.Mesh(geometry, materials);
                cube.position.set(i*spacing-offset, j*spacing-offset, k*spacing-offset);
                cube.isSolved = false;
                cube.greenFaceIndex = faceIndex;
                cube.gridPos = { i, j, k };
                const rand = Math.random();
                if (rand < 0.05) {
                    cube.type = 'bomb';
                    cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color:0xef4444, emissive:0x550000, metalness:0.2 });
                } else if (rand < 0.10) {
                    cube.type = 'time';
                    cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color:0x3b82f6, emissive:0x001a55, metalness:0.1 });
                } else {
                    cube.type = 'normal';
                    cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: greenProps.color, transparent: greenProps.transparent, opacity: greenProps.opacity, emissive: greenProps.color * 0.08 });
                }
                cubeGroup.add(cube);
            }
        }
    }

    // scale cubeGroup to fit smaller screens
    const minDim = Math.min(window.innerWidth, window.innerHeight);
    const targetScale = Math.min(1.0, Math.max(0.5, minDim/900));
    cubeGroup.scale.setScalar(targetScale);

    scene.add(cubeGroup);
}

/* helpers for disposing geometry/materials */
function disposeMaterial(mat){
    try{ if (mat.map) mat.map.dispose(); } catch(e){}
    try{ mat.dispose(); } catch(e){}
}
function disposeGroup(g){
    g.traverse(obj => {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(disposeMaterial);
            else disposeMaterial(obj.material);
        }
    });
}

/* interactions */
function handleCubeHit(clickedCube, faceIndex, screenX, screenY){
    if (isGameOver || clickedCube.isSolved) return;
    if (faceIndex === clickedCube.greenFaceIndex) {
        totalScore += 2;
        showFloatingScore('+2', screenX, screenY, '#bbf7d0');
        switch(clickedCube.type){
            case 'time': timer += 5; playSound('time'); destroyCube(clickedCube); break;
            case 'bomb': playSound('bomb'); detonateBomb(clickedCube, screenX, screenY); break;
            default: playSound('explosion'); destroyCube(clickedCube); break;
        }
    } else {
        totalScore -= 1;
        showFloatingScore('-1', screenX, screenY, '#fecaca');
        playSound('error');
    }
    updateUI();
}

function destroyCube(cube){
    if (cube.isSolved) return;
    cube.isSolved = true;
    destroyedThisLevel++;
    const mat = cube.material && cube.material[cube.greenFaceIndex] ? cube.material[cube.greenFaceIndex] : null;
    const color = mat && mat.color ? mat.color.getHex() : 0xffffff;
    createExplosion(cube.getWorldPosition(new THREE.Vector3()), color);
    cubeGroup.remove(cube);
    if (destroyedThisLevel >= (currentCubeSize*currentCubeSize*currentCubeSize)) {
        setTimeout(()=> levelComplete(), 250);
    }
}

function detonateBomb(bombCube, screenX, screenY){
    destroyCube(bombCube);
    const { i, j, k } = bombCube.gridPos;
    const cubesToDestroy = [];
    cubeGroup.children.forEach(targetCube => {
        if (targetCube.isSolved) return;
        const { i:ti, j:tj, k:tk } = targetCube.gridPos;
        const dist = Math.max(Math.abs(i-ti), Math.abs(j-tj), Math.abs(k-tk));
        if (dist === 1) cubesToDestroy.push(targetCube);
    });
    cubesToDestroy.forEach((target, index)=>{
        setTimeout(()=>{
            if (!target.isSolved) {
                totalScore += 2;
                playSound('explosion');
                const screenPos = worldToScreen(target.getWorldPosition(new THREE.Vector3()));
                showFloatingScore('+2', screenPos.x, screenPos.y, '#ffd7b5');
                destroyCube(target);
                updateUI();
            }
        }, 80*index);
    });
    showFloatingScore('BOOM', screenX, screenY, '#ffb4b4');
}

/* particles */
function createExplosion(position, colorHex){
    const particleCount = 28;
    for (let i=0;i<particleCount;i++){
        const particleGeometry = new THREE.SphereGeometry(0.04,8,8);
        const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent:true, opacity:1.0 });
        const particle = new THREE.Mesh(particleGeometry, mat);
        particle.position.copy(position);
        const velocity = new THREE.Vector3(
            (Math.random()-0.5)*(0.6+Math.random()*0.8),
            (Math.random()-0.25)*(0.6+Math.random()*0.8),
            (Math.random()-0.5)*(0.6+Math.random()*0.8)
        );
        particles.push({ mesh: particle, velocity: velocity, lifetime: 1.0 });
        scene.add(particle);
    }
}

function playSound(type){
    if (isMuted || !synths[type]) return;
    if (type === 'time') synths.time.triggerAttackRelease("C5", "0.35s");
    else if (type === 'error') synths.error.triggerAttackRelease("C2", "0.12s");
    else synths[type].triggerAttackRelease("8n");
}

function toggleMute(){
    isMuted = !isMuted;
    const unmutedIcon = document.getElementById('unmuted-icon');
    const mutedIcon = document.getElementById('muted-icon');
    if (isMuted) {
        Tone.Destination.volume.value = -Infinity;
        unmutedIcon.classList.add('hidden'); mutedIcon.classList.remove('hidden');
    } else {
        Tone.Destination.volume.value = 0;
        unmutedIcon.classList.remove('hidden'); mutedIcon.classList.add('hidden');
    }
}

/* input handling improved */
function onPointerDown(event){
    if (isGameOver) return;
    isDragging = false;
    previousMousePosition = { x: event.clientX, y: event.clientY };
}

function onPointerMove(event){
    if (isGameOver || !cubeGroup) return;
    const dx = event.clientX - previousMousePosition.x;
    const dy = event.clientY - previousMousePosition.y;
    if (!isDragging && (Math.abs(dx) > 4 || Math.abs(dy) > 4)) isDragging = true;
    if (isDragging){
        cubeGroup.rotation.y += dx * 0.006;
        cubeGroup.rotation.x += dy * 0.006;
        cubeGroup.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cubeGroup.rotation.x));
    }
    previousMousePosition = { x: event.clientX, y: event.clientY };
}

function onPointerUp(event){
    if (isGameOver) return;
    const dx = Math.abs(event.clientX - previousMousePosition.x);
    const dy = Math.abs(event.clientY - previousMousePosition.y);
    if (!isDragging && dx < 6 && dy < 6 && cubeGroup){
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cubeGroup.children, true);
        if (intersects.length > 0){
            const obj = intersects[0].object;
            const faceIdx = (intersects[0].face && typeof intersects[0].face.materialIndex === 'number') ? intersects[0].face.materialIndex : obj.greenFaceIndex;
            handleCubeHit(obj, faceIdx, event.clientX, event.clientY);
        }
    }
    isDragging = false;
}

/* floating score DOM */
function showFloatingScore(text, clientX, clientY, color='#bbf7d0'){
    const container = document.getElementById('floating-container');
    const el = document.createElement('div');
    el.className = 'floating-score';
    el.style.left = clientX + 'px';
    el.style.top = clientY + 'px';
    el.style.color = color;
    el.innerText = text;
    container.appendChild(el);
    requestAnimationFrame(()=> {
        el.style.transform = 'translate(-50%, -50%) translateY(-64px) scale(1.02)';
        el.style.opacity = '0';
    });
    setTimeout(()=> { if (el && el.parentNode) el.parentNode.removeChild(el); }, 1000);
}

/* world -> screen */
function worldToScreen(pos){
    const vector = pos.clone().project(camera);
    const x = (vector.x + 1)/2 * window.innerWidth;
    const y = (-vector.y + 1)/2 * window.innerHeight;
    return { x, y };
}

/* animation */
function animate(){
    requestAnimationFrame(animate);
    if (cubeGroup && !isDragging && !isGameOver) {
        cubeGroup.rotation.y += 0.0007;
        cubeGroup.rotation.x += 0.0003;
    }
    if (starfield) starfield.rotation.y += 0.00008;

    for (let i = particles.length-1; i>=0; i--){
        const p = particles[i];
        p.mesh.position.add(p.velocity);
        p.velocity.multiplyScalar(0.995);
        p.velocity.y -= 0.002;
        p.lifetime -= 0.016;
        p.mesh.material.opacity = Math.max(0, p.lifetime);
        if (p.lifetime <= 0) {
            scene.remove(p.mesh);
            if (p.mesh.geometry) p.mesh.geometry.dispose();
            if (p.mesh.material) p.mesh.material.dispose();
            particles.splice(i,1);
        }
    }

    renderer.render(scene, camera);
}

/* window resize */
function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/* =============================
   Firebase Auth + Leaderboard
   ============================= */
async function googleLogin(){
    const provider = new firebase.auth.GoogleAuthProvider();
    try {
        const result = await auth.signInWithPopup(provider);
        currentUser = result.user;
        document.getElementById('login-section').classList.add('hidden');
        document.getElementById('start-message').classList.remove('hidden');
        document.getElementById('login-info').innerText = `Login sebagai ${currentUser.displayName}`;
        document.getElementById('login-info').style.opacity = 0.95;
    } catch (e) {
        alert('Login gagal: ' + (e.message || e));
    }
}

async function loadLeaderboard(){
    try {
        const snapshot = await db.collection('leaderboard').orderBy('score','desc').limit(10).get();
        const list = document.getElementById('leaderboard-list');
        list.innerHTML = '';
        snapshot.forEach(doc => {
            const data = doc.data();
            const li = document.createElement('li');
            li.className = 'flex items-center gap-2';
            li.innerHTML = `
                <img src="${data.photo || ''}" class="w-6 h-6 rounded-full" onerror="this.style.display='none'">
                <span style="flex:1">${data.name || 'Anon'}</span>
                <span class="font-bold">${data.score || 0}</span>
            `;
            list.appendChild(li);
        });
        document.getElementById('leaderboard').classList.remove('hidden');
    } catch (e) {
        console.error('Failed to load leaderboard', e);
    }
}

/* Reset & try again helpers */
function resetGame(){
    // reset everything
    totalScore = 0;
    currentCubeSize = 3;
    currentLevelIndex = 0;
    document.getElementById('win-message').classList.add('hidden');
    document.getElementById('login-section').classList.add('hidden');
    document.getElementById('start-message').classList.remove('hidden');
    document.getElementById('leaderboard').classList.add('hidden');
}

function tryAgain(){
    document.getElementById('lose-message').classList.add('hidden');
    // restart same wave size and level
    destroyedThisLevel = 0;
    startGame(levels[currentLevelIndex]);
}

</script>
</body>
</html>