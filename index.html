<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Kubus 3D - Progresif</title>
    <!-- Memuat Tailwind CSS untuk styling UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Memuat Three.js untuk grafis 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Memuat Tone.js untuk audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }
        .overlay-ui { position: absolute; padding: 10px 20px; background-color: rgba(0, 0, 0, 0.7); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 1.1rem; font-weight: 600; text-align: center; border: 1px solid rgba(255, 255, 255, 0.2); backdrop-filter: blur(5px); }
        #game-info { top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; }
        .message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 40px; text-align: center; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 90%; max-width: 500px; background-color: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .title { font-size: 2.5rem; font-weight: bold; }
        .btn { background-color: #4a5568; padding: 12px 24px; border-radius: 8px; font-size: 1.1rem; font-weight: 600; margin-top: 20px; cursor: pointer; transition: background-color 0.3s, transform 0.2s; }
        .btn:hover { background-color: #2d3748; transform: scale(1.05); }
        #mute-btn { position: absolute; bottom: 20px; right: 20px; width: 50px; height: 50px; background-color: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 100; }
    </style>
</head>
<body>
    <!-- UI Overlay: Skor, Waktu, Level -->
    <div id="game-ui" class="hidden">
        <div id="game-info" class="overlay-ui">
            <div id="score-board">Skor: 0</div>
            <div id="timer">Waktu: 120</div>
            <div id="difficulty-display">Level: -</div>
        </div>
    </div>

    <!-- Pesan-pesan Game -->
    <div id="start-message" class="message-box flex-col items-center">
        <span class="title">Game Kubus 3D</span>
        <p class="mt-4 text-lg">Hancurkan sisi kubus yang berwarna hijau! Hati-hati dengan bom!</p>
        <button id="start-btn" class="btn">Mulai Game</button>
    </div>
    <div id="level-complete-message" class="message-box hidden flex-col items-center">
        <span class="title">Level Selesai!</span>
        <p id="level-score-breakdown" class="mt-4 text-lg"></p>
        <button id="continue-btn" class="btn">Lanjut ke Level Berikutnya</button>
    </div>
    <div id="win-message" class="message-box hidden flex-col items-center">
        <span class="title">Selamat!</span>
        <p class="mt-2 text-lg">Anda telah menyelesaikan semua level!</p>
        <p id="final-score" class="mt-4 text-2xl font-bold"></p>
        <button class="btn" onclick="location.reload()">Main Lagi</button>
    </div>
    <div id="lose-message" class="message-box hidden flex-col items-center">
        <span class="title">Waktu Habis!</span>
        <p id="lose-score" class="mt-4 text-2xl font-bold"></p>
        <button class="btn" onclick="location.reload()">Coba Lagi</button>
    </div>
    
    <!-- Tombol Mute -->
    <button id="mute-btn">
        <svg id="unmuted-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
        <svg id="muted-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
    </button>

    <script>
        // --- Inisialisasi Variabel Global ---
        let scene, camera, renderer, cubeGroup, starfield;
        let totalScore = 0, timer, gameInterval, destroyedThisLevel = 0;
        const totalCubes = 4 * 4 * 4;
        let isGameOver = true, isMuted = false;
        let particles = [];
        const levels = ['Mudah', 'Sedang', 'Sulit'];
        let currentLevelIndex = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let synths = {};

        // --- Panggil Fungsi Inisialisasi ---
        initScene();
        animate();
        
        // --- Inisialisasi Scene & Audio ---
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            document.getElementById('mute-btn').addEventListener('click', toggleMute);
            document.getElementById('continue-btn').addEventListener('click', loadNextLevel);
            document.getElementById('start-btn').addEventListener('click', () => {
                // Sembunyikan layar awal dan mulai game
                document.getElementById('start-message').classList.add('hidden');
                document.getElementById('start-message').classList.remove('flex');
                initAudio();
                startGame(levels[currentLevelIndex]);
            });
        }

        async function initAudio() {
            // Memulai konteks audio hanya setelah interaksi pengguna
            await Tone.start();
            synths.explosion = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            synths.bomb = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: "exponential" } }).toDestination();
            synths.time = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination();
            synths.error = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
        }

        // --- Kontrol Alur Game ---
        function startGame(difficulty) {
            isGameOver = false;
            document.getElementById('game-ui').classList.remove('hidden');

            // Reset state level
            destroyedThisLevel = 0;
            timer = 120; // Waktu mulai untuk setiap level
            updateUI();

            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(updateTimer, 1000);
            
            Tone.Transport.start();

            if (!starfield) createStarfield();
            createRubikCube(difficulty);
        }

        function updateTimer() {
            timer--;
            updateUI();
            if (timer <= 0) {
                gameOver(false);
            }
        }

        function levelComplete() {
            isGameOver = true; // Jeda game sementara
            clearInterval(gameInterval);
            Tone.Transport.stop();

            const timeBonus = timer;
            totalScore += timeBonus;
            
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('level-score-breakdown').innerHTML = `Bonus Waktu: ${timeBonus} Poin<br>Total Skor Saat Ini: ${totalScore}`;
            document.getElementById('level-complete-message').classList.remove('hidden');
            document.getElementById('level-complete-message').classList.add('flex');
        }

        function loadNextLevel() {
            document.getElementById('level-complete-message').classList.add('hidden');
            currentLevelIndex++;
            if (currentLevelIndex < levels.length) {
                startGame(levels[currentLevelIndex]);
            } else {
                gameOver(true); // Menang semua level
            }
        }

        function gameOver(isWin) {
            isGameOver = true;
            clearInterval(gameInterval);
            Tone.Transport.stop();
            document.getElementById('game-ui').classList.add('hidden');
            if (isWin) {
                document.getElementById('final-score').innerText = `Skor Akhir Anda: ${totalScore}`;
                document.getElementById('win-message').classList.remove('hidden');
                document.getElementById('win-message').classList.add('flex');
            } else {
                document.getElementById('lose-score').innerText = `Skor Akhir Anda: ${totalScore}`;
                document.getElementById('lose-message').classList.remove('hidden');
                document.getElementById('lose-message').classList.add('flex');
            }
        }
        
        function updateUI() {
            document.getElementById('score-board').innerText = `Skor: ${totalScore}`;
            document.getElementById('timer').innerText = `Waktu: ${timer}`;
            document.getElementById('difficulty-display').innerText = `Level: ${levels[currentLevelIndex]}`;
        }

        // --- Pembuatan Objek 3D ---
        // FUNGSI BARU: Membuat latar belakang bintang 3D.
        function createStarfield() {
            const starCount = 5000;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();
            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(200);
                const y = THREE.MathUtils.randFloatSpread(200);
                const z = THREE.MathUtils.randFloatSpread(200);
                positions.push(x, y, z);
                color.setHSL(0.6, 0.2, Math.random() * 0.5 + 0.5);
                colors.push(color.r, color.g, color.b);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const starMaterial = new THREE.PointsMaterial({
                size: 0.1,
                sizeAttenuation: true,
                transparent: true,
                vertexColors: true
            });
            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        function createRubikCube(difficulty) {
            if (cubeGroup) scene.remove(cubeGroup);
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];
            
            cubeGroup = new THREE.Group();
            const size = 4, spacing = 1.1, cubeSize = 1;
            const offset = (size - 1) * spacing / 2;
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            let greenProps = { color: 0x22c55e, transparent: true, opacity: 1.0 };
            if (difficulty === 'Sedang') greenProps.opacity = 0.6;
            else if (difficulty === 'Sulit') { greenProps.opacity = 0.35; greenProps.color = 0x166534; }

            for (let i = 0; i < size; i++) for (let j = 0; j < size; j++) for (let k = 0; k < size; k++) {
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x111827, name: 'black' });
                const materials = Array(6).fill(blackMat);
                const faceIndex = Math.floor(Math.random() * 6);
                const cube = new THREE.Mesh(geometry, materials);
                cube.position.set(i * spacing - offset, j * spacing - offset, k * spacing - offset);
                cube.isSolved = false;
                cube.greenFaceIndex = faceIndex;
                cube.gridPos = {i, j, k};
                const rand = Math.random();
                if (rand < 0.05) { cube.type = 'bomb'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0xef4444, emissive: 0x550000, name: 'special' }); }
                else if (rand < 0.10) { cube.type = 'time'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x000055, name: 'special' }); }
                else { cube.type = 'normal'; cube.material[faceIndex] = new THREE.MeshStandardMaterial({ ...greenProps, name: 'special' }); }
                cubeGroup.add(cube);
            }
            scene.add(cubeGroup);
        }

        // --- Logika Game & Interaksi ---
        function handleCubeHit(clickedCube, faceIndex) {
            if (isGameOver || clickedCube.isSolved) return;
            
            if (faceIndex === clickedCube.greenFaceIndex) {
                totalScore += 2;
                switch(clickedCube.type) {
                    case 'time': timer += 5; playSound('time'); destroyCube(clickedCube); break;
                    case 'bomb': playSound('bomb'); detonateBomb(clickedCube); break;
                    default: playSound('explosion'); destroyCube(clickedCube); break;
                }
            } else { // Klik salah
                totalScore -= 1;
                playSound('error');
            }
            updateUI();
        }

        function destroyCube(cube) {
            if (cube.isSolved) return;
            cube.isSolved = true;
            destroyedThisLevel++;
            const color = cube.material[cube.greenFaceIndex].color;
            createExplosion(cube.getWorldPosition(new THREE.Vector3()), color);
            cubeGroup.remove(cube);
            if (destroyedThisLevel === totalCubes) {
                levelComplete();
            }
        }
        
        function detonateBomb(bombCube) {
            destroyCube(bombCube);
            const { i, j, k } = bombCube.gridPos;
            const cubesToDestroy = [];
            cubeGroup.children.forEach(targetCube => {
                if (targetCube.isSolved) return;
                const { i: ti, j: tj, k: tk } = targetCube.gridPos;
                const dist = Math.max(Math.abs(i-ti), Math.abs(j-tj), Math.abs(k-tk));
                if (dist === 1) cubesToDestroy.push(targetCube);
            });
            cubesToDestroy.forEach((target, index) => {
                 setTimeout(() => {
                    if (!target.isSolved) {
                       totalScore += 2; // Tambah skor untuk setiap kubus yg hancur oleh bom
                       playSound('explosion');
                       destroyCube(target);
                       updateUI();
                    }
                }, 100 * (index / 5));
            });
        }
        
        // FUNGSI BARU: Membuat efek partikel ledakan.
        function createExplosion(position, color) {
            const particleCount = 25;
            const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true });
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                particles.push({ mesh: particle, velocity: velocity, lifetime: 1.0 });
                scene.add(particle);
            }
        }

        function playSound(type) {
            if (isMuted || !synths[type]) return;
            if (type === 'time') synths.time.triggerAttackRelease("C5", "0.5s");
            else if (type === 'error') synths.error.triggerAttackRelease("C2", "0.1s");
            else synths[type].triggerAttackRelease("8n");
        }

        // FUNGSI BARU: Mengatur tombol mute dan status audio.
        function toggleMute() {
            isMuted = !isMuted;
            const unmutedIcon = document.getElementById('unmuted-icon');
            const mutedIcon = document.getElementById('muted-icon');
            if (isMuted) {
                Tone.Destination.volume.value = -Infinity; // Mematikan volume
                unmutedIcon.classList.add('hidden');
                mutedIcon.classList.remove('hidden');
            } else {
                Tone.Destination.volume.value = 0; // Mengaktifkan volume
                unmutedIcon.classList.remove('hidden');
                mutedIcon.classList.add('hidden');
            }
        }

        // --- Event Handlers & Loop Animasi ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function onPointerDown(event) {
            if (isGameOver) return;
            isDragging = false; // Reset dragging state on new click to differentiate drag from click
            setTimeout(() => isDragging = true, 150); // A small delay to allow click detection
            
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        function onPointerMove(event) {
            if (isDragging && !isGameOver && cubeGroup) {
                const deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y };
                if(Math.abs(deltaMove.x) > 2 || Math.abs(deltaMove.y) > 2) { // only rotate if moved significantly
                     cubeGroup.rotation.y += deltaMove.x * 0.005;
                     cubeGroup.rotation.x += deltaMove.y * 0.005;
                }
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }
        function onPointerUp(event) {
            const dx = Math.abs(event.clientX - previousMousePosition.x);
            const dy = Math.abs(event.clientY - previousMousePosition.y);

            // only register as a click if the mouse/finger hasn't moved much
            if (dx < 5 && dy < 5 && !isGameOver) {
                 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                 raycaster.setFromCamera(mouse, camera);
                 const intersects = raycaster.intersectObjects(cubeGroup.children);
                 if (intersects.length > 0) {
                     handleCubeHit(intersects[0].object, intersects[0].face.materialIndex);
                 }
            }
            isDragging = false;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (cubeGroup && !isDragging && !isGameOver) {
                cubeGroup.rotation.y += 0.0005;
                cubeGroup.rotation.x += 0.0002;
            }
            if(starfield) starfield.rotation.y += 0.0001;
            particles.forEach((p, index) => {
                p.mesh.position.add(p.velocity);
                p.velocity.y -= 0.0015;
                p.lifetime -= 0.016;
                p.mesh.material.opacity = Math.max(0, p.lifetime);
                if (p.lifetime <= 0) { scene.remove(p.mesh); particles.splice(index, 1); }
            });
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

